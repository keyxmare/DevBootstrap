"""Neovim configuration manager."""

import os
import shutil
import json
from dataclasses import dataclass, field
from typing import Optional
from enum import Enum

from .utils.system import SystemInfo
from .utils.cli import CLI
from .utils.runner import CommandRunner


class ConfigPreset(Enum):
    """Available configuration presets."""
    MINIMAL = "minimal"
    STANDARD = "standard"
    FULL = "full"
    CUSTOM = "custom"


@dataclass
class ConfigOptions:
    """Configuration options."""
    preset: ConfigPreset = ConfigPreset.STANDARD
    config_dir: str = ""
    backup_existing: bool = True
    install_plugins: bool = True
    custom_config_path: Optional[str] = None  # Path to import custom config from


class ConfigManager:
    """Manages Neovim configuration installation and customization."""

    # Base configuration directory in this project
    BUNDLED_CONFIGS_DIR = os.path.join(os.path.dirname(__file__), "..", "configs", "nvim")

    def __init__(self, system_info: SystemInfo, cli: CLI, runner: CommandRunner):
        """Initialize the configuration manager."""
        self.system_info = system_info
        self.cli = cli
        self.runner = runner
        self.config_dir = system_info.get_config_dir()
        self.data_dir = system_info.get_data_dir()

    def backup_existing_config(self) -> Optional[str]:
        """Backup existing Neovim configuration. Returns backup path or None."""
        import datetime

        if not os.path.exists(self.config_dir):
            return None

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = f"{self.config_dir}.backup.{timestamp}"

        self.cli.print_info(f"Sauvegarde vers {backup_dir}")

        try:
            shutil.copytree(self.config_dir, backup_dir)
            return backup_dir
        except Exception as e:
            self.cli.print_error(f"Erreur lors de la sauvegarde: {e}")
            return None

    def clear_config(self) -> bool:
        """Clear existing Neovim configuration and data."""
        try:
            if os.path.exists(self.config_dir):
                shutil.rmtree(self.config_dir)
                self.cli.print_info(f"Configuration supprimée: {self.config_dir}")

            # Also clear plugin data for a fresh start
            if os.path.exists(self.data_dir):
                shutil.rmtree(self.data_dir)
                self.cli.print_info(f"Données supprimées: {self.data_dir}")

            return True
        except Exception as e:
            self.cli.print_error(f"Erreur: {e}")
            return False

    def install_preset(self, preset: ConfigPreset) -> bool:
        """Install a configuration preset."""
        self.cli.print_section(f"Installation de la configuration ({preset.value})")

        # Ensure config directory exists
        self.runner.ensure_directory(self.config_dir)

        if preset == ConfigPreset.MINIMAL:
            return self._install_minimal_config()
        elif preset == ConfigPreset.STANDARD:
            return self._install_standard_config()
        elif preset == ConfigPreset.FULL:
            return self._install_full_config()
        else:
            self.cli.print_warning("Preset personnalisé - aucune configuration installée")
            return True

    def _install_minimal_config(self) -> bool:
        """Install minimal Neovim configuration."""
        init_lua = os.path.join(self.config_dir, "init.lua")

        config_content = '''-- Minimal Neovim Configuration
-- Generated by nvim-installer

-- Basic options
vim.opt.number = true
vim.opt.relativenumber = true
vim.opt.mouse = "a"
vim.opt.clipboard = "unnamedplus"
vim.opt.expandtab = true
vim.opt.shiftwidth = 4
vim.opt.tabstop = 4
vim.opt.smartindent = true
vim.opt.wrap = false
vim.opt.termguicolors = true
vim.opt.signcolumn = "yes"
vim.opt.updatetime = 250
vim.opt.timeoutlen = 300
vim.opt.splitright = true
vim.opt.splitbelow = true
vim.opt.ignorecase = true
vim.opt.smartcase = true
vim.opt.hlsearch = true
vim.opt.incsearch = true
vim.opt.scrolloff = 8
vim.opt.sidescrolloff = 8
vim.opt.cursorline = true
vim.opt.undofile = true

-- Leader key
vim.g.mapleader = " "
vim.g.maplocalleader = " "

-- Basic keymaps
vim.keymap.set("n", "<Esc>", "<cmd>nohlsearch<CR>")
vim.keymap.set("n", "<leader>w", "<cmd>w<CR>", { desc = "Save" })
vim.keymap.set("n", "<leader>q", "<cmd>q<CR>", { desc = "Quit" })

-- Window navigation
vim.keymap.set("n", "<C-h>", "<C-w>h", { desc = "Go to left window" })
vim.keymap.set("n", "<C-j>", "<C-w>j", { desc = "Go to lower window" })
vim.keymap.set("n", "<C-k>", "<C-w>k", { desc = "Go to upper window" })
vim.keymap.set("n", "<C-l>", "<C-w>l", { desc = "Go to right window" })

-- Better indenting
vim.keymap.set("v", "<", "<gv")
vim.keymap.set("v", ">", ">gv")

print("Neovim minimal config loaded!")
'''

        try:
            with open(init_lua, "w") as f:
                f.write(config_content)
            self.cli.print_success("Configuration minimale installée")
            return True
        except Exception as e:
            self.cli.print_error(f"Erreur: {e}")
            return False

    def _install_standard_config(self) -> bool:
        """Install standard Neovim configuration with lazy.nvim and essential plugins."""
        # Create directory structure
        lua_dir = os.path.join(self.config_dir, "lua")
        plugins_dir = os.path.join(lua_dir, "plugins")
        self.runner.ensure_directory(plugins_dir)

        # Main init.lua
        init_content = '''-- Standard Neovim Configuration
-- Generated by nvim-installer

-- Bootstrap lazy.nvim
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable",
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)

-- Leader key (must be before lazy)
vim.g.mapleader = " "
vim.g.maplocalleader = " "

-- Load core options
require("core.options")
require("core.keymaps")
require("core.autocmds")

-- Load plugins
require("lazy").setup("plugins", {
  defaults = { lazy = true },
  install = { colorscheme = { "catppuccin", "habamax" } },
  checker = { enabled = true, notify = false },
  change_detection = { notify = false },
  performance = {
    rtp = {
      disabled_plugins = {
        "gzip",
        "tarPlugin",
        "tohtml",
        "tutor",
        "zipPlugin",
      },
    },
  },
})
'''

        # Core options
        options_content = '''-- Core Neovim options

local opt = vim.opt

-- Line numbers
opt.number = true
opt.relativenumber = true

-- Tabs & indentation
opt.tabstop = 4
opt.shiftwidth = 4
opt.expandtab = true
opt.autoindent = true
opt.smartindent = true

-- Line wrapping
opt.wrap = false

-- Search settings
opt.ignorecase = true
opt.smartcase = true
opt.hlsearch = true
opt.incsearch = true

-- Cursor line
opt.cursorline = true

-- Appearance
opt.termguicolors = true
opt.background = "dark"
opt.signcolumn = "yes"

-- Backspace
opt.backspace = "indent,eol,start"

-- Clipboard
opt.clipboard = "unnamedplus"

-- Split windows
opt.splitright = true
opt.splitbelow = true

-- Consider - as part of word
opt.iskeyword:append("-")

-- Scrolloff
opt.scrolloff = 8
opt.sidescrolloff = 8

-- Update time
opt.updatetime = 250
opt.timeoutlen = 300

-- Undo
opt.undofile = true
opt.undolevels = 10000

-- Mouse
opt.mouse = "a"

-- Disable swap files
opt.swapfile = false

-- Better completion
opt.completeopt = "menu,menuone,noselect"

-- Concealment for markdown etc
opt.conceallevel = 2
'''

        # Core keymaps
        keymaps_content = '''-- Core keymaps

local keymap = vim.keymap.set

-- Clear search highlight
keymap("n", "<Esc>", "<cmd>nohlsearch<CR>")

-- Save & quit
keymap("n", "<leader>w", "<cmd>w<CR>", { desc = "Save" })
keymap("n", "<leader>q", "<cmd>q<CR>", { desc = "Quit" })
keymap("n", "<leader>Q", "<cmd>qa!<CR>", { desc = "Force quit all" })

-- Window navigation
keymap("n", "<C-h>", "<C-w>h", { desc = "Go to left window" })
keymap("n", "<C-j>", "<C-w>j", { desc = "Go to lower window" })
keymap("n", "<C-k>", "<C-w>k", { desc = "Go to upper window" })
keymap("n", "<C-l>", "<C-w>l", { desc = "Go to right window" })

-- Resize windows
keymap("n", "<C-Up>", "<cmd>resize +2<CR>", { desc = "Increase window height" })
keymap("n", "<C-Down>", "<cmd>resize -2<CR>", { desc = "Decrease window height" })
keymap("n", "<C-Left>", "<cmd>vertical resize -2<CR>", { desc = "Decrease window width" })
keymap("n", "<C-Right>", "<cmd>vertical resize +2<CR>", { desc = "Increase window width" })

-- Buffer navigation
keymap("n", "<S-h>", "<cmd>bprevious<CR>", { desc = "Prev buffer" })
keymap("n", "<S-l>", "<cmd>bnext<CR>", { desc = "Next buffer" })
keymap("n", "<leader>bd", "<cmd>bdelete<CR>", { desc = "Delete buffer" })

-- Better indenting
keymap("v", "<", "<gv")
keymap("v", ">", ">gv")

-- Move lines
keymap("n", "<A-j>", "<cmd>m .+1<CR>==", { desc = "Move down" })
keymap("n", "<A-k>", "<cmd>m .-2<CR>==", { desc = "Move up" })
keymap("v", "<A-j>", ":m '>+1<CR>gv=gv", { desc = "Move down" })
keymap("v", "<A-k>", ":m '<-2<CR>gv=gv", { desc = "Move up" })

-- Better paste
keymap("v", "p", '"_dP', { desc = "Paste without yanking" })

-- Quick splits
keymap("n", "<leader>sv", "<C-w>v", { desc = "Split vertical" })
keymap("n", "<leader>sh", "<C-w>s", { desc = "Split horizontal" })
keymap("n", "<leader>se", "<C-w>=", { desc = "Equal splits" })
keymap("n", "<leader>sx", "<cmd>close<CR>", { desc = "Close split" })

-- Diagnostic keymaps
keymap("n", "[d", vim.diagnostic.goto_prev, { desc = "Go to previous diagnostic" })
keymap("n", "]d", vim.diagnostic.goto_next, { desc = "Go to next diagnostic" })
keymap("n", "<leader>e", vim.diagnostic.open_float, { desc = "Show diagnostic" })
'''

        # Core autocmds
        autocmds_content = '''-- Core autocommands

local autocmd = vim.api.nvim_create_autocmd
local augroup = vim.api.nvim_create_augroup

-- Highlight on yank
autocmd("TextYankPost", {
  group = augroup("highlight_yank", { clear = true }),
  callback = function()
    vim.highlight.on_yank({ higroup = "IncSearch", timeout = 200 })
  end,
})

-- Resize splits on window resize
autocmd("VimResized", {
  group = augroup("resize_splits", { clear = true }),
  callback = function()
    vim.cmd("tabdo wincmd =")
  end,
})

-- Go to last location when opening a buffer
autocmd("BufReadPost", {
  group = augroup("last_loc", { clear = true }),
  callback = function()
    local mark = vim.api.nvim_buf_get_mark(0, '"')
    local lcount = vim.api.nvim_buf_line_count(0)
    if mark[1] > 0 and mark[1] <= lcount then
      pcall(vim.api.nvim_win_set_cursor, 0, mark)
    end
  end,
})

-- Close some filetypes with <q>
autocmd("FileType", {
  group = augroup("close_with_q", { clear = true }),
  pattern = {
    "help",
    "lspinfo",
    "man",
    "notify",
    "qf",
    "checkhealth",
  },
  callback = function(event)
    vim.bo[event.buf].buflisted = false
    vim.keymap.set("n", "q", "<cmd>close<CR>", { buffer = event.buf, silent = true })
  end,
})

-- Auto create dir when saving a file
autocmd("BufWritePre", {
  group = augroup("auto_create_dir", { clear = true }),
  callback = function(event)
    if event.match:match("^%w%w+://") then
      return
    end
    local file = vim.loop.fs_realpath(event.match) or event.match
    vim.fn.mkdir(vim.fn.fnamemodify(file, ":p:h"), "p")
  end,
})
'''

        # Plugin: colorscheme
        colorscheme_content = '''-- Colorscheme configuration
return {
  {
    "catppuccin/nvim",
    name = "catppuccin",
    priority = 1000,
    lazy = false,
    config = function()
      require("catppuccin").setup({
        flavour = "mocha",
        transparent_background = false,
        integrations = {
          cmp = true,
          gitsigns = true,
          nvimtree = true,
          telescope = true,
          treesitter = true,
          which_key = true,
          mini = true,
        },
      })
      vim.cmd.colorscheme("catppuccin")
    end,
  },
}
'''

        # Plugin: treesitter
        treesitter_content = '''-- Treesitter configuration
return {
  {
    "nvim-treesitter/nvim-treesitter",
    build = ":TSUpdate",
    event = { "BufReadPost", "BufNewFile" },
    dependencies = {
      "nvim-treesitter/nvim-treesitter-textobjects",
    },
    config = function()
      require("nvim-treesitter.configs").setup({
        ensure_installed = {
          "bash",
          "c",
          "html",
          "javascript",
          "json",
          "lua",
          "luadoc",
          "luap",
          "markdown",
          "markdown_inline",
          "python",
          "query",
          "regex",
          "tsx",
          "typescript",
          "vim",
          "vimdoc",
          "yaml",
        },
        auto_install = true,
        highlight = { enable = true },
        indent = { enable = true },
        incremental_selection = {
          enable = true,
          keymaps = {
            init_selection = "<C-space>",
            node_incremental = "<C-space>",
            scope_incremental = false,
            node_decremental = "<bs>",
          },
        },
      })
    end,
  },
}
'''

        # Plugin: telescope
        telescope_content = '''-- Telescope configuration
return {
  {
    "nvim-telescope/telescope.nvim",
    cmd = "Telescope",
    branch = "0.1.x",
    dependencies = {
      "nvim-lua/plenary.nvim",
      {
        "nvim-telescope/telescope-fzf-native.nvim",
        build = "make",
        cond = function()
          return vim.fn.executable("make") == 1
        end,
      },
    },
    keys = {
      { "<leader>ff", "<cmd>Telescope find_files<CR>", desc = "Find files" },
      { "<leader>fg", "<cmd>Telescope live_grep<CR>", desc = "Live grep" },
      { "<leader>fb", "<cmd>Telescope buffers<CR>", desc = "Buffers" },
      { "<leader>fh", "<cmd>Telescope help_tags<CR>", desc = "Help tags" },
      { "<leader>fr", "<cmd>Telescope oldfiles<CR>", desc = "Recent files" },
      { "<leader>fc", "<cmd>Telescope grep_string<CR>", desc = "Grep word under cursor" },
      { "<leader><leader>", "<cmd>Telescope buffers<CR>", desc = "Buffers" },
      { "<leader>/", "<cmd>Telescope current_buffer_fuzzy_find<CR>", desc = "Search in buffer" },
    },
    config = function()
      local telescope = require("telescope")
      local actions = require("telescope.actions")

      telescope.setup({
        defaults = {
          mappings = {
            i = {
              ["<C-j>"] = actions.move_selection_next,
              ["<C-k>"] = actions.move_selection_previous,
              ["<C-q>"] = actions.send_selected_to_qflist + actions.open_qflist,
            },
          },
          file_ignore_patterns = { "node_modules", ".git/" },
        },
      })

      pcall(telescope.load_extension, "fzf")
    end,
  },
}
'''

        # Plugin: LSP
        lsp_content = '''-- LSP configuration
return {
  {
    "neovim/nvim-lspconfig",
    event = { "BufReadPre", "BufNewFile" },
    dependencies = {
      "williamboman/mason.nvim",
      "williamboman/mason-lspconfig.nvim",
      { "j-hui/fidget.nvim", opts = {} },
    },
    config = function()
      -- Setup Mason first
      require("mason").setup({
        ui = {
          border = "rounded",
          icons = {
            package_installed = "✓",
            package_pending = "➜",
            package_uninstalled = "✗",
          },
        },
      })

      require("mason-lspconfig").setup({
        ensure_installed = {
          "lua_ls",
          "pyright",
          "ts_ls",
        },
        automatic_installation = true,
      })

      -- LSP keymaps
      vim.api.nvim_create_autocmd("LspAttach", {
        group = vim.api.nvim_create_augroup("lsp-attach", { clear = true }),
        callback = function(event)
          local map = function(keys, func, desc)
            vim.keymap.set("n", keys, func, { buffer = event.buf, desc = "LSP: " .. desc })
          end

          map("gd", vim.lsp.buf.definition, "Go to definition")
          map("gr", vim.lsp.buf.references, "Go to references")
          map("gI", vim.lsp.buf.implementation, "Go to implementation")
          map("gy", vim.lsp.buf.type_definition, "Go to type definition")
          map("gD", vim.lsp.buf.declaration, "Go to declaration")
          map("K", vim.lsp.buf.hover, "Hover documentation")
          map("<leader>ca", vim.lsp.buf.code_action, "Code action")
          map("<leader>rn", vim.lsp.buf.rename, "Rename")
          map("<leader>D", vim.lsp.buf.type_definition, "Type definition")
        end,
      })

      -- Configure LSP servers
      local lspconfig = require("lspconfig")
      local capabilities = vim.lsp.protocol.make_client_capabilities()

      -- Try to enhance with cmp capabilities
      local ok, cmp_lsp = pcall(require, "cmp_nvim_lsp")
      if ok then
        capabilities = vim.tbl_deep_extend("force", capabilities, cmp_lsp.default_capabilities())
      end

      -- Lua
      lspconfig.lua_ls.setup({
        capabilities = capabilities,
        settings = {
          Lua = {
            workspace = { checkThirdParty = false },
            telemetry = { enable = false },
            diagnostics = { globals = { "vim" } },
          },
        },
      })

      -- Python
      lspconfig.pyright.setup({ capabilities = capabilities })

      -- TypeScript
      lspconfig.ts_ls.setup({ capabilities = capabilities })
    end,
  },
}
'''

        # Plugin: completion
        completion_content = '''-- Completion configuration
return {
  {
    "hrsh7th/nvim-cmp",
    event = "InsertEnter",
    dependencies = {
      "hrsh7th/cmp-nvim-lsp",
      "hrsh7th/cmp-buffer",
      "hrsh7th/cmp-path",
      "L3MON4D3/LuaSnip",
      "saadparwaiz1/cmp_luasnip",
      "rafamadriz/friendly-snippets",
    },
    config = function()
      local cmp = require("cmp")
      local luasnip = require("luasnip")

      require("luasnip.loaders.from_vscode").lazy_load()
      luasnip.config.setup({})

      cmp.setup({
        snippet = {
          expand = function(args)
            luasnip.lsp_expand(args.body)
          end,
        },
        completion = { completeopt = "menu,menuone,noinsert" },
        mapping = cmp.mapping.preset.insert({
          ["<C-n>"] = cmp.mapping.select_next_item(),
          ["<C-p>"] = cmp.mapping.select_prev_item(),
          ["<C-b>"] = cmp.mapping.scroll_docs(-4),
          ["<C-f>"] = cmp.mapping.scroll_docs(4),
          ["<C-y>"] = cmp.mapping.confirm({ select = true }),
          ["<C-Space>"] = cmp.mapping.complete({}),
          ["<Tab>"] = cmp.mapping(function(fallback)
            if cmp.visible() then
              cmp.select_next_item()
            elseif luasnip.expand_or_locally_jumpable() then
              luasnip.expand_or_jump()
            else
              fallback()
            end
          end, { "i", "s" }),
          ["<S-Tab>"] = cmp.mapping(function(fallback)
            if cmp.visible() then
              cmp.select_prev_item()
            elseif luasnip.locally_jumpable(-1) then
              luasnip.jump(-1)
            else
              fallback()
            end
          end, { "i", "s" }),
        }),
        sources = {
          { name = "nvim_lsp" },
          { name = "luasnip" },
          { name = "buffer" },
          { name = "path" },
        },
      })
    end,
  },
}
'''

        # Plugin: UI enhancements
        ui_content = '''-- UI enhancements
return {
  -- Status line
  {
    "nvim-lualine/lualine.nvim",
    event = "VeryLazy",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    opts = {
      options = {
        theme = "catppuccin",
        component_separators = { left = "", right = "" },
        section_separators = { left = "", right = "" },
      },
    },
  },

  -- Indent guides
  {
    "lukas-reineke/indent-blankline.nvim",
    event = { "BufReadPost", "BufNewFile" },
    main = "ibl",
    opts = {
      indent = { char = "│" },
      scope = { enabled = false },
    },
  },

  -- Git signs
  {
    "lewis6991/gitsigns.nvim",
    event = { "BufReadPost", "BufNewFile" },
    opts = {
      signs = {
        add = { text = "▎" },
        change = { text = "▎" },
        delete = { text = "" },
        topdelete = { text = "" },
        changedelete = { text = "▎" },
      },
      on_attach = function(buffer)
        local gs = package.loaded.gitsigns

        local function map(mode, l, r, desc)
          vim.keymap.set(mode, l, r, { buffer = buffer, desc = desc })
        end

        map("n", "]h", gs.next_hunk, "Next hunk")
        map("n", "[h", gs.prev_hunk, "Prev hunk")
        map("n", "<leader>hs", gs.stage_hunk, "Stage hunk")
        map("n", "<leader>hr", gs.reset_hunk, "Reset hunk")
        map("n", "<leader>hp", gs.preview_hunk, "Preview hunk")
        map("n", "<leader>hb", function() gs.blame_line({ full = true }) end, "Blame line")
      end,
    },
  },

  -- Which-key
  {
    "folke/which-key.nvim",
    event = "VeryLazy",
    opts = {
      plugins = { spelling = true },
    },
    config = function(_, opts)
      local wk = require("which-key")
      wk.setup(opts)
      wk.add({
        { "<leader>f", group = "file/find" },
        { "<leader>g", group = "git" },
        { "<leader>h", group = "hunk" },
        { "<leader>s", group = "split" },
        { "<leader>b", group = "buffer" },
        { "<leader>c", group = "code" },
      })
    end,
  },

  -- File explorer
  {
    "nvim-tree/nvim-tree.lua",
    cmd = { "NvimTreeToggle", "NvimTreeFocus" },
    keys = {
      { "<leader>e", "<cmd>NvimTreeToggle<CR>", desc = "Toggle file explorer" },
    },
    dependencies = { "nvim-tree/nvim-web-devicons" },
    opts = {
      filters = { dotfiles = false },
      disable_netrw = true,
      hijack_cursor = true,
      sync_root_with_cwd = true,
      view = { width = 30 },
      renderer = {
        root_folder_label = false,
        highlight_git = true,
        icons = {
          show = {
            git = true,
          },
        },
      },
    },
  },

  -- Auto pairs
  {
    "windwp/nvim-autopairs",
    event = "InsertEnter",
    opts = {},
  },

  -- Comments
  {
    "numToStr/Comment.nvim",
    keys = {
      { "gcc", mode = "n", desc = "Comment toggle line" },
      { "gc", mode = { "n", "v" }, desc = "Comment toggle" },
    },
    opts = {},
  },

  -- Mini plugins
  {
    "echasnovski/mini.surround",
    keys = {
      { "sa", desc = "Add surrounding", mode = { "n", "v" } },
      { "sd", desc = "Delete surrounding" },
      { "sr", desc = "Replace surrounding" },
    },
    opts = {},
  },
}
'''

        try:
            # Create core directory
            core_dir = os.path.join(lua_dir, "core")
            self.runner.ensure_directory(core_dir)

            # Write all files
            files = [
                (os.path.join(self.config_dir, "init.lua"), init_content),
                (os.path.join(core_dir, "options.lua"), options_content),
                (os.path.join(core_dir, "keymaps.lua"), keymaps_content),
                (os.path.join(core_dir, "autocmds.lua"), autocmds_content),
                (os.path.join(plugins_dir, "colorscheme.lua"), colorscheme_content),
                (os.path.join(plugins_dir, "treesitter.lua"), treesitter_content),
                (os.path.join(plugins_dir, "telescope.lua"), telescope_content),
                (os.path.join(plugins_dir, "lsp.lua"), lsp_content),
                (os.path.join(plugins_dir, "completion.lua"), completion_content),
                (os.path.join(plugins_dir, "ui.lua"), ui_content),
            ]

            for filepath, content in files:
                with open(filepath, "w") as f:
                    f.write(content)
                self.cli.print_success(f"Créé: {os.path.basename(filepath)}")

            self.cli.print_success("Configuration standard installée")
            return True

        except Exception as e:
            self.cli.print_error(f"Erreur: {e}")
            return False

    def _install_full_config(self) -> bool:
        """Install full configuration (standard + extra plugins)."""
        # First install standard config
        if not self._install_standard_config():
            return False

        # Add extra plugins
        plugins_dir = os.path.join(self.config_dir, "lua", "plugins")

        # Plugin: extra tools
        extra_content = '''-- Extra tools and plugins
return {
  -- Lazygit integration
  {
    "kdheepak/lazygit.nvim",
    cmd = "LazyGit",
    keys = {
      { "<leader>gg", "<cmd>LazyGit<CR>", desc = "LazyGit" },
    },
  },

  -- Todo comments
  {
    "folke/todo-comments.nvim",
    event = { "BufReadPost", "BufNewFile" },
    dependencies = { "nvim-lua/plenary.nvim" },
    opts = {},
    keys = {
      { "<leader>ft", "<cmd>TodoTelescope<CR>", desc = "Find TODOs" },
    },
  },

  -- Trouble (diagnostics list)
  {
    "folke/trouble.nvim",
    cmd = { "Trouble" },
    keys = {
      { "<leader>xx", "<cmd>Trouble diagnostics toggle<CR>", desc = "Diagnostics" },
      { "<leader>xX", "<cmd>Trouble diagnostics toggle filter.buf=0<CR>", desc = "Buffer diagnostics" },
    },
    opts = {},
  },

  -- Better terminal
  {
    "akinsho/toggleterm.nvim",
    cmd = "ToggleTerm",
    keys = {
      { "<C-/>", "<cmd>ToggleTerm<CR>", desc = "Toggle terminal" },
      { "<leader>tf", "<cmd>ToggleTerm direction=float<CR>", desc = "Float terminal" },
      { "<leader>th", "<cmd>ToggleTerm direction=horizontal<CR>", desc = "Horizontal terminal" },
      { "<leader>tv", "<cmd>ToggleTerm direction=vertical size=80<CR>", desc = "Vertical terminal" },
    },
    opts = {
      open_mapping = [[<C-/>]],
      direction = "float",
      float_opts = {
        border = "curved",
      },
    },
  },

  -- Session management
  {
    "folke/persistence.nvim",
    event = "BufReadPre",
    opts = {},
    keys = {
      { "<leader>qs", function() require("persistence").load() end, desc = "Restore session" },
      { "<leader>ql", function() require("persistence").load({ last = true }) end, desc = "Restore last session" },
      { "<leader>qd", function() require("persistence").stop() end, desc = "Don't save session" },
    },
  },

  -- Better UI
  {
    "stevearc/dressing.nvim",
    event = "VeryLazy",
    opts = {},
  },

  -- Notifications
  {
    "rcarriga/nvim-notify",
    event = "VeryLazy",
    opts = {
      timeout = 3000,
      max_height = function()
        return math.floor(vim.o.lines * 0.75)
      end,
      max_width = function()
        return math.floor(vim.o.columns * 0.75)
      end,
    },
    config = function(_, opts)
      require("notify").setup(opts)
      vim.notify = require("notify")
    end,
  },

  -- Dashboard
  {
    "goolord/alpha-nvim",
    event = "VimEnter",
    dependencies = { "nvim-tree/nvim-web-devicons" },
    config = function()
      local alpha = require("alpha")
      local dashboard = require("alpha.themes.dashboard")

      dashboard.section.header.val = {
        [[                                                    ]],
        [[ ███╗   ██╗███████╗ ██████╗ ██╗   ██╗██╗███╗   ███╗ ]],
        [[ ████╗  ██║██╔════╝██╔═══██╗██║   ██║██║████╗ ████║ ]],
        [[ ██╔██╗ ██║█████╗  ██║   ██║██║   ██║██║██╔████╔██║ ]],
        [[ ██║╚██╗██║██╔══╝  ██║   ██║╚██╗ ██╔╝██║██║╚██╔╝██║ ]],
        [[ ██║ ╚████║███████╗╚██████╔╝ ╚████╔╝ ██║██║ ╚═╝ ██║ ]],
        [[ ╚═╝  ╚═══╝╚══════╝ ╚═════╝   ╚═══╝  ╚═╝╚═╝     ╚═╝ ]],
        [[                                                    ]],
      }

      dashboard.section.buttons.val = {
        dashboard.button("f", "  Find file", "<cmd>Telescope find_files<CR>"),
        dashboard.button("n", "  New file", "<cmd>ene <BAR> startinsert<CR>"),
        dashboard.button("r", "  Recent files", "<cmd>Telescope oldfiles<CR>"),
        dashboard.button("g", "  Find text", "<cmd>Telescope live_grep<CR>"),
        dashboard.button("c", "  Config", "<cmd>e $MYVIMRC<CR>"),
        dashboard.button("s", "  Restore session", [[<cmd>lua require("persistence").load()<CR>]]),
        dashboard.button("l", "󰒲  Lazy", "<cmd>Lazy<CR>"),
        dashboard.button("q", "  Quit", "<cmd>qa<CR>"),
      }

      alpha.setup(dashboard.opts)
    end,
  },

  -- Markdown preview
  {
    "iamcco/markdown-preview.nvim",
    cmd = { "MarkdownPreviewToggle", "MarkdownPreview", "MarkdownPreviewStop" },
    ft = { "markdown" },
    build = function() vim.fn["mkdp#util#install"]() end,
  },
}
'''

        try:
            extra_path = os.path.join(plugins_dir, "extra.lua")
            with open(extra_path, "w") as f:
                f.write(extra_content)

            self.cli.print_success("Plugins additionnels ajoutés")
            return True

        except Exception as e:
            self.cli.print_error(f"Erreur: {e}")
            return False

    def import_custom_config(self, source_path: str) -> bool:
        """Import a custom configuration from a path or git URL."""
        self.cli.print_section("Import de configuration personnalisée")

        if source_path.startswith(("http://", "https://", "git@")):
            # Git repository
            return self._import_from_git(source_path)
        elif os.path.isdir(source_path):
            # Local directory
            return self._import_from_directory(source_path)
        else:
            self.cli.print_error(f"Source invalide: {source_path}")
            return False

    def _import_from_git(self, repo_url: str) -> bool:
        """Import configuration from a git repository."""
        self.cli.print_info(f"Clonage de {repo_url}...")

        # Clear existing config
        if os.path.exists(self.config_dir):
            self.runner.remove(self.config_dir)

        result = self.runner.run(
            ["git", "clone", "--depth=1", repo_url, self.config_dir],
            description="Clonage du repository",
            sudo=False,
            timeout=120
        )

        if result.success:
            # Remove .git directory for cleaner setup
            git_dir = os.path.join(self.config_dir, ".git")
            if os.path.exists(git_dir):
                shutil.rmtree(git_dir)
            self.cli.print_success("Configuration importée avec succès")
            return True

        self.cli.print_error(f"Échec du clonage: {result.stderr}")
        return False

    def _import_from_directory(self, source_dir: str) -> bool:
        """Import configuration from a local directory."""
        self.cli.print_info(f"Copie depuis {source_dir}...")

        # Clear existing config
        if os.path.exists(self.config_dir):
            self.runner.remove(self.config_dir)

        return self.runner.copy_directory(source_dir, self.config_dir)

    def sync_plugins(self) -> bool:
        """Synchronize plugins by running Neovim headless."""
        self.cli.print_section("Synchronisation des plugins")

        if not self.runner.check_command_exists("nvim"):
            self.cli.print_error("Neovim n'est pas installé")
            return False

        self.cli.print_info("Lancement de la synchronisation (cela peut prendre quelques minutes)...")

        # Run Neovim headless to install plugins
        result = self.runner.run(
            ["nvim", "--headless", "+Lazy! sync", "+qa"],
            description="Synchronisation des plugins",
            sudo=False,
            timeout=600  # 10 minutes for plugin download
        )

        if result.success:
            self.cli.print_success("Plugins synchronisés")
            return True

        # Even if return code is non-zero, plugins might have installed
        self.cli.print_warning("La synchronisation peut être incomplète")
        return True

    def setup(self, options: ConfigOptions) -> bool:
        """Run the complete configuration setup."""
        # Backup if needed
        if options.backup_existing and os.path.exists(self.config_dir):
            backup_path = self.backup_existing_config()
            if backup_path:
                self.cli.print_success(f"Sauvegarde créée: {backup_path}")

        # Clear existing config
        self.clear_config()

        # Install preset or custom config
        if options.custom_config_path:
            if not self.import_custom_config(options.custom_config_path):
                return False
        else:
            if not self.install_preset(options.preset):
                return False

        # Sync plugins if requested
        if options.install_plugins:
            self.sync_plugins()

        return True
